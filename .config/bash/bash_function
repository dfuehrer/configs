#!/bin/bash
# make a directory and cd into it
cdmd () { mkdir $1 && cd $1; }
# # just got this from the archwiki, it makes man have colors
# # dont need it anymore cause i made a bash script that does this with search functionality
# man () {
# 	LESS_TERMCAP_md=$'\e[01;31m' \
# 	LESS_TERMCAP_me=$'\e[0m' \
# 	LESS_TERMCAP_se=$'\e[0m' \
# 	LESS_TERMCAP_so=$'\e[01;44;33m' \
# 	LESS_TERMCAP_ue=$'\e[0m' \
# 	LESS_TERMCAP_us=$'\e[01;32m' \
# 	command man "$@";
# }
# sort all printenv if no args but if args print out what works and then remove the uppercase and send all to upper and print that out (this should prevent overlap and make it so lowercase works for upper which is as case insensitive as i usually care about (if i want case insensitive i can just env | grep -i "$@"))
pe () { [ -z "$1" ] && printenv | sort || { printenv "$@"; lower="$( echo "$@" | tr -d '[:upper:]' | tr '[:lower:]' '[:upper:]' )" && [ -n "$lower" ] && printenv $lower; }; }

# stole this from which manpage
# This will print the readable ~/ and ./ when starting which from your prompt, while still printing the full path in scripts
which () {
    (alias; declare -f) | command which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}
# TODO do i need this?
export -f which

lfcd () {
    export FIFO_CD="$(mktemp -ut lf-cd.XXXXXXXXXX)"
    mkfifo "$FIFO_CD"
    cleanup() {
        exec 3>&-
        rm "$FIFO_CD"
    }

    while [ -e "$FIFO_CD" ]; do read -r dir; cd "$dir"; sleep 1; done < "$FIFO_CD" &
    exec 3>"$FIFO_CD"
    # TODO i dont know if this works for functions
    trap cleanup EXIT

    # TODO figure out whats gonig on here
    lf "$@" 3>&-
}
